#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef unsigned int    size_j;

char	**ft_split(char const *, char);
char    **ft_addsplit(char**, char *, char *);
char    *ft_unitsplit(const char *, const char *);
char    **ft_splitset(char  **, const char  *, size_j);

int     main(void)
{
    char    prueba[] = "Esteuneeeeeeeeeeeeestringeedeeeeeeeeeeeeeeeeeeeeeeeeeprueba";
    //para este caso el String falla, reparar!
    char    **response;
    char    *response_strtok;
    char    *dlim = "e";
    //response_strtok = strtok(prueba, dlim);
    //printf("valor original: %s\n", response_strtok);
    response = ft_split(prueba, 'e');
    if (response == 0)
    {
        printf("response es null");
    }
    else
    {
        printf("puntero: %p, primer valor:%s\n", *(response + 5), *(response + 5));
        
        if (*(response + 3) == 0)
        {
            printf("response 3 es NULL");
        }
        else
        {
            printf("response 3 no es NULL");
        }
    }
}

char	**ft_split(char const *s, char c)
{   
    char    *diff_end;
    char    *offset;
    size_j  counter;
    short   flag;
    char    **splitted;
    
    counter = 0;
    flag = 0;
    splitted = (char **)0;
    while (*(s + counter) != '\0')
    {
        if (*(s + counter) != c)
        {   
            if (flag == 0)
            {
                offset = (char *)s + counter;
                flag = 1;
            }
            counter++;
            while (*(s + counter) != c && *(s+ counter) != '\0')
            {
                counter++;
            }
            if (flag == 1)
            {
                diff_end = (char *)s + counter;
                flag = 0;
                splitted = ft_addsplit(splitted, offset, diff_end);
            }
        }
        else
        {
            if (flag == 1)
            {
                diff_end = (char *)s + counter;
                splitted = ft_addsplit(splitted, offset, diff_end);
            }
            counter++;
            while (*(s + counter) == c && *(s + counter) != '\0')
            {
                counter++;
            }
            offset = (char *)s + counter;
            flag = 1;
        }
        counter++;
    }
    return (splitted);
}

char    **ft_addsplit(char** splitset, char *offset, char *diff_end)
{
    static size_j  nelem;
    char    *tmp_splitset;
    
    nelem++;
    tmp_splitset = ft_unitsplit(offset, diff_end);
    if (tmp_splitset != 0)
    {
        splitset = ft_splitset(splitset, tmp_splitset, nelem);
        if (splitset != 0)
        {
            return (splitset);
        }
        return ((char **)0);
    }
    return ((char **)0);
}

char    **ft_splitset(char  **splitset, const char  *tmp_splitset, size_j nelem)
{
        char    **tmp;

        if (nelem == 1)
        {
            splitset = (char **)malloc(sizeof(char *));
            if (splitset != 0)
            {
                *splitset = (char *)tmp_splitset;
                return (splitset);
            }
            return ((char **)0);
        }
        else
        {
            tmp = (char **)malloc(sizeof(char *) * (nelem + 1));
            if (tmp != 0)
            {   
                *(tmp + (nelem--)) = (char *)0;
                *(tmp + nelem) = (char *)tmp_splitset;
                while (nelem--)
                {
                    *(tmp + nelem) = *(splitset + nelem);
                }
                free(splitset);
                return(tmp);
            }
            return ((char **)0);
        }
}

char    *ft_unitsplit(const char *offset, const char *diff_end)
{
    char    *memsetted;
    size_j  diff_mem;
    
    diff_mem = diff_end - offset + 1;
    memsetted = (char *)malloc(sizeof(char) * (diff_mem));
    if (memsetted != 0)
    {   
        *(memsetted + (--diff_mem)) = '\0';
        while (diff_mem--)
        {
            diff_end--;
            *(memsetted + diff_mem) = *diff_end;
        }
        return (memsetted);
    }
    return ((void *)0);
}
FUNCIONA PERFECTAMENTE, ARRAY TERMINA EN NULL
DEMASIADO EXTENSO
FALLA AL NO ENCONTRAR OCURRENCIES DEVUELVE TODO EL STRING.
FALLA AL ESTABLECER UN STRING COMO: eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeea\0
------------------------------------------------------------------ANOTHER ONE: ft_split.c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

typedef unsigned int    size_j;

char	*ft_strchr(const char *, int);
char	*ft_strdup(const char *);
char	**ft_split(char const *, char);
size_j	ft_strlen(const char *);
void	*ft_memcpy(void *restrict, const void *restrict, size_j);
void	*ft_memset(void *, int, size_j);

int     main(void)
{
    char    prueba[] = "Esteeeeeeeeeeeeeeeeeeuneeeeeeeeeeeeestringeedeeeeeeeeeeeeeeeeeeeeeeeeeprueba";
    //para este caso el String falla, reparar!
    char    **response;
    char    *response_strtok;
    char    *dlim = "e";
    response_strtok = strtok(prueba, dlim);
    printf("valor original: %s\n", response_strtok);
    response = ft_split(prueba, 'e');
    if (response == 0)
    {
        printf("response es null");
    }
    else
    {
        printf("puntero: %p, primer valor:%s\n", *(response + 2), *(response + 2));
        
        if (*(response + 3) == 0)
        {
            printf("response 3 es NULL");
        }
        else
        {
            printf("response 3 no es NULL");
        }
    }
}

char	**ft_split(char const *s, char c)
{
	char	*duplicated;
	char	**splitted;
	size_j	n_ocurrencies;
	size_j	counter;

	duplicated = ft_strdup(s);
	n_ocurrencies = 2;
	counter = 0;
	while (*s != '\0')
	{
		if (*s == c)
			n_ocurrencies++;
        s++;
	}
	splitted = (char **)malloc(sizeof(char *) * (n_ocurrencies));
	if (splitted != 0 && n_ocurrencies > 2)
	{
		while (n_ocurrencies)
		{
			*(splitted + counter) = duplicated;
			duplicated = ft_strchr(duplicated, c);
			n_ocurrencies--;
			if (duplicated == 0)
			{
			    *(splitted + counter + 1) = (char *)0;
				break; 
			}
			else
			{
			    ft_memset(duplicated, 0, 1);
			    duplicated++;
			}
			counter++;

		}
		return (splitted);
	}
	return ((char **)0);
}

char	*ft_strdup(const char *s)
{
	char	*dup;
	size_j	s_len;

	s_len = ft_strlen(s);
	dup = (char *)malloc(s_len);
	if (dup == (char *)0)
	{
		return (dup);
	}
	dup = (char *)ft_memcpy(dup, s, s_len);
	return (dup);
}

char	*ft_strchr(const char *s, int c)
{	
	while (*s != '\0')
	{
		if (*s == c)
		{
			return ((char *)s);
		}
		s++;
	}
	if (c == 0)
		return ((char *)s);
	return ((void *)0);
}

size_j	ft_strlen(const char *s)
{
	int	counter;

	counter = 0;
	while (*s != '\0')
	{
		counter++;
		s++;
	}
	return (counter);
}

void	*ft_memcpy(void *restrict dest, const void *restrict src, size_j n)
{
	while (n--)
	{
		*(char *)(dest + n) = *(char *)(src + n);
	}
	return (dest);
}

void	*ft_memset(void *s, int c, size_j n)
{
	while (n--)
	{
		*(char *)(s + n) = c;
	}
	return (s);
}
_______________________________________________________________________OTHER ONE: ft_split.c
/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/
this is the string is tha one
#include <stdio.h>
#include <strings.h>
#include <ctype.h>
#include <string.h>
#include <bsd/string.h>

typedef unsigned int    size_j;
char	*ft_strnstr(const char *, const char *, size_j);

int main()
{
    char    s2[20] = "is tha";
    char    s1[30] = "this is tha string one";
    printf("owned: %p", ft_strnstr(s1, s2, 20));
    return 0;
}
//s2 == little, s1 == big, no more than n-bytes are searched.
//Characters that appear after '\0' are not searched
//if little is empty, return big.
//if little ocurrs nowhere, return NULL
//successed, return the first character from the first ocurrence.
char	*ft_strnstr(const char *s1, const char *s2, size_j n)
{
    size_j  counter;
   //Esta verificado y funciona correctamente, sin embargo, la cantidad
   //maxima de lineas permitidas están excedidas, averiguar la manera
   //de hacerlo más pequeño. 
    counter = 0;
    if (*s2 == '\0')
        return ((char *)s1);
    while (*s1 != '\0' && *s2 != '\0' && n--)
    {
        if (*s1 == *s2)
        {   
            s1++;
            counter++;
            while(n-- && *s2 != '\0' && *s1 != '\0')
            {
                if (*s1 == *(s2 + counter))
                {
                    s1++;
                    counter++;                    
                }
                else
                {  
                    s1--;
                   break; 
                }
            }
            if (*(s2 + counter) == '\0')
                return ((char *)(s1 - counter + 1));
        }
        counter = 0;
        s1++;
    }
	return ((void *)0);
}
---------------------------------------------------------------------------OTHER ONE: ft_strnstr.c
/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <stdio.h>
#include <strings.h>
#include <ctype.h>
#include <string.h>
#include <bsd/string.h>

typedef unsigned int    size_j;
size_j	ft_strlcat(char *, const char *, size_j);
size_j	ft_strlen(const char *);
size_j	ft_strlcpy(char *, const char *, size_j);

int main()
{
    char    s1[] = "this is the string one,";
    char    s2[20] = "this is ";
    char    s3[20];
    printf("value inside the array %d\n", *(s2 + 21));
    printf("initial position %p y %s\n", s1, s2);
    printf("owned: %d y dest: %s\n", ft_strlcat(s2, s1, 20), s2);
    printf("result: %s\n", s2);
    return 0;
}

size_j	ft_strlcpy(char *dest, const char *src, size_j n)
{
	size_j	counter;

	counter = 0;
	while (counter < n && *src != '\0')
	{
		*(dest + counter) = *(src + counter);
        counter++;
	}
	*(dest + counter) = '\0';
	return (counter);
}

size_j	ft_strlcat(char *dest, const char *src, size_j n)
{
	size_j	counter;
	size_j	size_free;
	size_j	size_dest;
	size_j  size_src;


	size_dest = ft_strlen(dest);
	size_free = n - size_dest;
	if (size_free > 0)
	{
	    counter = ft_strlcpy((dest + size_dest), src, size_free);
	}
	*(dest + size_dest + size_free + 1) = '\0';
	return (counter);
}

size_j	ft_strlen(const char *s)
{
	int	counter;

	counter = 0;
	while (*s != '\0')
	{
		counter++;
		s++;
	}
	return (counter);
}
--------------------------------------------------------------------OTHER ONE: strlcat & strlcpy
/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <stdio.h>
#include <strings.h>
#include <ctype.h>

typedef unsigned int    size_j;
int	ft_isalnum(int);

int main()
{
    char    c1 = 'A';
    printf("original: %d, owned: %d", isalnum(c1), ft_isalnum(c1));
    return 0;
}

int	ft_isalnum(int c)
{
	if (c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')
	{
		return (1);
	}
	return (0);
}


_____________________________________________________________OTHER ONE : VERIFIYING Ft_ISALNUM.C
/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>

typedef unsigned int    size_j;
void	*ft_calloc(size_j, size_j);

int main()
{
    char    *str;
    char    *str2;
    int     counter;
    
    counter = 0;
    str = (char *) ft_calloc(20, 1);
    str2 = (char *) calloc(20, 1);
    
    while (counter < 20)
    {
        (str2 + counter);
        *str2 = 'a';
        counter ++;
    }
    *(str2 + counter) = '\0';
    printf("%s\n", str2);
    
    printf("owned: %p\n calloc: %p\n ", str, str2);
    return 0;
}

void	*ft_calloc(size_j nmemb, size_j size)
{
	size_j	totalmem;
    void     *err;
    int     errno;
    
    errno = 1;
    err = &errno;
	totalmem = nmemb * size;
	if (totalmem == 0)
	{
		return 0;
	}
	else if (totalmem > 1844674407370955165)
	{
		return err;
	}
	return (malloc(totalmem));

}
aaaaaaaaaaaaaaaaaaaa
-------------------------------------------------------------------------OTHER ONE, CALLOC
/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>

typedef unsigned int    size_j;
int	ft_atoi(const char *);
int	ft_makeint(const char *, const char *);
int	ft_isdigit(int);

int main()
{
    char    str[20] = "-1232adsasdsa";
    int     number;
    int     number2;
    
    number = ft_atoi(str);
    number2 = atoi(str);
    printf("%d\n", number);
    printf("%d\n", number2);
    return 0;
}

int	ft_atoi(const char *s1)
{	
	size_j	counter;
	char	*duplicated;

	counter = 0;
	while (*s1 != '\0')
	{
		if (ft_isdigit(*s1) == 0 && *s1 != '-' || *s1 == '+')
		{
			if (counter == 0)
			{
				return (0);
			}
			return (ft_makeint(duplicated, s1 - 1));
		}
		else
		{
			if (counter == 0)
			{
				duplicated = (char *) s1;
			}
			counter++;
		}
		s1++;
	}
}

int	ft_makeint(const char *duplicated, const char *endup)
{	
	size_j	counter;
	int		number;

	counter = 1;
	number = 0;
	while (endup >= duplicated)
	{
	    if (*endup == '-')
	    {
	        (*(endup + 1) << 7) || (10000000); 
	    }
		number += counter * (*endup - '0');
		
		counter *= 10;
		endup--;
	}
	return (number);
}

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
	{
		return (1);
	}
	return (0);
}

------------------------------------------------------------------------------------OTHER ONE
/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/

#include <stdio.h>

void    *ft_memmove(void *, const void *, unsigned int);

int main()
{
    char    src[] = "this is a Sttring overlaping";
    
    ft_memmove(src, src + 6, 10);
    printf("%s\n", src);
    return 0;
}

void    *ft_memmove(void *dest, const void *src, unsigned int n)
{       
        int     counter;
        
        counter = 0;
        if (dest > src)
        {
            while (n--)
            {
                *(char *) (dest + n) = *(char *) (src + n);
            }
        }
        else
        {
            while (counter < n)
            {
                *(char *) (dest++) = *(char *) (src++);
                counter++;
            }
        }
        return (dest);
}
-------------------------------------------------------------------------------------OTHER ONE
/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

typedef	unsigned int	size_j;
void	ft_bzero(void *, size_j);
int     ft_isalnum(int);
int	    ft_isalpha(int);
int	    ft_isascii(int);
int	    ft_isdigit(int);
int	    ft_isprint(int);
void	*ft_memcpy(void *restrict, const void *restrict, size_j);
void	*ft_memset(void *, int, size_j);
size_j	ft_strlen(const char *);
void    *ft_memmove(void *, const void *, size_j);
void	*ft_getsrc(const void *, void *, size_j);
void    *ft_setdest(const void *, void *, size_j);

int	main(void)
{
	char	src[] = "aabbcc";

	ft_memmove(src + 2, src, 2);

	write(0, src, 7);
    write(0, "Estamos en main", 15);
	return (0);
}

void	*ft_memmove(void *dest, const void *src, size_j n)
{
    size_j  size_src;
    size_j  size_dest;
    
    size_src = ft_strlen((char *) src);
    size_dest = ft_strlen((char *) dest);
    char    tmp[10000];
	ft_getsrc(src, tmp, n);
	ft_setdest(tmp, dest, size_dest);
	return (dest);
}

void	*ft_getsrc(const void *src, void *tmp, size_j n)
{
	size_j	counter;
	int     flag;

	counter = 0;
	while (*(char *) src != '\0' && counter < n)
	{
		*(char *) tmp = *(char *) src;
		tmp++;
		src++;
		counter++;
	}
	flag = 1;
	return (tmp);
}

void	*ft_setdest(const void *tmp, void *dest, size_j n)
{
	size_j	counter;
	int flag;
    
	counter = 0;
	while (*(char *) tmp != '\0' && counter < n)
	{   
		*(char *) dest = *(char *) tmp;
		dest++;
		tmp++;
		counter++;
	}
	return (dest);
}

size_j	ft_strlen(const char *s)
{
	int	counter;
	char    *p;
	int     flag;

	counter = 0;
	while (*s != '\0')
	{
		counter++;
		s++;
	}

    flag = 1;
	return (counter);
}

--------------------------------------------------------------------------------------OTHER ONE
/******************************************************************************

                            Online C Compiler.
                Code, Compile, Run and Debug C program online.
Write your code in this editor and press "Run" button to compile and execute it.

*******************************************************************************/
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

typedef	unsigned int	size_j;
void	ft_bzero(void *, size_j);
int     ft_isalnum(int);
int	    ft_isalpha(int);
int	    ft_isascii(int);
int	    ft_isdigit(int);
int	    ft_isprint(int);
void	*ft_memcpy(void *restrict, const void *restrict, size_j);
void	*ft_memset(void *, int, size_j);
size_j	ft_strlen(const char *);
void    *ft_memmove(void *, const void *, size_j);
void	*ft_getsrc(const void *, void *, size_j);
void    *ft_setdest(const void *, void *, size_j);
size_j	ft_strlcat(char *, const char *, size_j);

int	main(void)
{   
    size_j  counted;
	char	src[] = "this is a long string";
    char    dest[20];//si le reservo menos espacio de memoria, este puede
                    //sobreescribir en espacios de memorias ajenos de otras variables
                    //como lo podia presenciar en src cuando el tamaño era dest[15]
    
	counted = ft_strlcat(dest, src, 20);
    
    printf("%s\n", dest);
    printf("%s\n", src);
    printf("%d\n", counted);
	//write(0, dest, 12);
    write(0, "Estamos en main", 15);
	return (0);
}

size_j	ft_strlcat(char *dest, const char *src, size_j n)
{
	size_j	counter;
	size_j  size_free;
	size_j  size_dest;

	counter = 0;
	size_dest = ft_strlen(dest);
	size_free = n - size_dest;
	dest += size_dest;
	while (counter < size_free)
	{
		*dest = *src;
		dest++;
		src++;
		counter++;
	}
	*dest = '\0';
	return (counter);
}

size_j	ft_strlen(const char *s)
{
	int	counter;

	counter = 0;
	while (*s != '\0')
	{
		counter++;
		s++;
	}
	return (counter);
}